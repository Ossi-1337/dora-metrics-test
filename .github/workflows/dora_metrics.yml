name: DORA metrics

on:
  schedule:
    # Runs every day at 03:00 UTC
    - cron: "0 3 * * *"
  workflow_dispatch: {}

jobs:
  dora-metrics:
    runs-on: ubuntu-latest

    env:
      MAIN_BRANCH: main
      WINDOW_DAYS: 30            # look back this many days
      CI_WORKFLOW: ci.yml
      SECURITY_WORKFLOW: security.yml

    outputs:
      deployment_frequency: ${{ steps.dora.outputs.deployment_frequency }}
      lead_time_hours_avg: ${{ steps.dora.outputs.lead_time_hours_avg }}
      lead_time_hours_median: ${{ steps.dora.outputs.lead_time_hours_median }}
      change_failure_rate: ${{ steps.dora.outputs.change_failure_rate }}
      mttr_hours: ${{ steps.dora.outputs.mttr_hours }}

    steps:
      - name: Calculate DORA metrics
        id: dora
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const mainBranch = process.env.MAIN_BRANCH || 'main';
            const windowDays = Number(process.env.WINDOW_DAYS || '30');
            const ciWorkflow = process.env.CI_WORKFLOW || 'ci.yml';
            const securityWorkflow = process.env.SECURITY_WORKFLOW || 'security.yml';

            const { owner, repo } = context.repo;
            const now = new Date();
            const since = new Date(now.getTime() - windowDays * 24 * 60 * 60 * 1000);

            core.info(`Calculating DORA metrics for ${owner}/${repo}`);
            core.info(`Main branch: ${mainBranch}`);
            core.info(`Window: last ${windowDays} days (since ${since.toISOString()})`);

            // ---------- Helper functions ----------
            async function getMergedPrsInWindow() {
              const prs = await github.paginate(github.rest.pulls.list, {
                owner,
                repo,
                state: 'closed',
                base: mainBranch,
                sort: 'updated',
                direction: 'desc',
                per_page: 100,
              });

              const mergedInWindow = prs.filter(pr => {
                if (!pr.merged_at) return false;
                const mergedAt = new Date(pr.merged_at);
                return mergedAt >= since;
              });

              core.info(`Found ${mergedInWindow.length} PRs merged into ${mainBranch} in window`);
              return mergedInWindow;
            }

            async function getWorkflowRunsInWindow(workflowFile) {
              const allRuns = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                {
                  owner,
                  repo,
                  workflow_id: workflowFile,
                  per_page: 100,
                  branch: mainBranch,
                }
              );

              const filtered = allRuns.filter(run => {
                const createdAt = new Date(run.created_at);
                return createdAt >= since;
              });

              core.info(
                `Workflow ${workflowFile}: ${filtered.length} runs on ${mainBranch} in window`
              );
              return filtered;
            }

            function average(arr) {
              if (!arr.length) return 0;
              return arr.reduce((a, b) => a + b, 0) / arr.length;
            }

            function median(arr) {
              if (!arr.length) return 0;
              const sorted = [...arr].sort((a, b) => a - b);
              const mid = Math.floor(sorted.length / 2);
              if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
              }
              return sorted[mid];
            }

            function groupFinalRunBySha(runs) {
              // Final (latest) run per head_sha
              const map = new Map();
              const sorted = [...runs].sort(
                (a, b) => new Date(a.created_at) - new Date(b.created_at)
              );
              for (const run of sorted) {
                if (run.head_branch !== mainBranch) continue;
                map.set(run.head_sha, run); // later runs overwrite earlier ones
              }
              return map;
            }

            function computeMttrHours(runs) {
              const relevant = runs.filter(r => r.head_branch === mainBranch);
              if (!relevant.length) return 0;

              const sorted = [...relevant].sort(
                (a, b) => new Date(a.created_at) - new Date(b.created_at)
              );

              const failureStates = new Set(['failure', 'cancelled', 'timed_out']);
              const successStates = new Set(['success']);

              const episodes = [];
              let failureStart = null;

              for (const run of sorted) {
                const t = new Date(run.created_at);
                const conclusion = run.conclusion;

                if (failureStates.has(conclusion)) {
                  if (!failureStart) {
                    failureStart = t;
                  }
                } else if (successStates.has(conclusion)) {
                  if (failureStart) {
                    const deltaMs = t - failureStart;
                    if (deltaMs > 0) {
                      episodes.push(deltaMs);
                    }
                    failureStart = null;
                  }
                }
              }

              if (!episodes.length) return 0;
              const avgMs = average(episodes);
              return avgMs / (1000 * 60 * 60); // hours
            }

            // ---------- 1) Deployment Frequency + Lead Time ----------
            const mergedPrs = await getMergedPrsInWindow();
            const deploymentCount = mergedPrs.length;

            const leadTimesHours = mergedPrs.map(pr => {
              const created = new Date(pr.created_at);
              const merged = new Date(pr.merged_at);
              const deltaMs = merged - created;
              return deltaMs / (1000 * 60 * 60); // hours
            });

            const leadTimeAvg = average(leadTimesHours);
            const leadTimeMedian = median(leadTimesHours);

            core.info(`Deployment frequency (PR merges): ${deploymentCount}`);
            core.info(`Lead time - avg (hours): ${leadTimeAvg.toFixed(2)}`);
            core.info(`Lead time - median (hours): ${leadTimeMedian.toFixed(2)}`);

            // ---------- 2) Change Failure Rate ----------
            const ciRuns = await getWorkflowRunsInWindow(ciWorkflow);
            const secRuns = await getWorkflowRunsInWindow(securityWorkflow);

            const ciBySha = groupFinalRunBySha(ciRuns);
            const secBySha = groupFinalRunBySha(secRuns);

            let deploymentsWithBuilds = 0;
            let failedDeployments = 0;
            const failureStates = new Set(['failure', 'cancelled', 'timed_out']);

            for (const pr of mergedPrs) {
              const sha = pr.merge_commit_sha;
              if (!sha) continue;

              const runsForDeployment = [];
              const ciRun = ciBySha.get(sha);
              const secRun = secBySha.get(sha);
              if (ciRun) runsForDeployment.push(ciRun);
              if (secRun) runsForDeployment.push(secRun);

              if (!runsForDeployment.length) {
                // No builds found for this deployment in window â€” skip from denominator
                continue;
              }

              deploymentsWithBuilds++;

              const hasFailure = runsForDeployment.some(run =>
                failureStates.has(run.conclusion)
              );

              if (hasFailure) {
                failedDeployments++;
              }
            }

            const changeFailureRate =
              deploymentsWithBuilds === 0
                ? 0
                : failedDeployments / deploymentsWithBuilds;

            core.info(
              `Deployments with builds in window: ${deploymentsWithBuilds}, failed deployments: ${failedDeployments}`
            );
            core.info(
              `Change Failure Rate: ${(changeFailureRate * 100).toFixed(2)}%`
            );

            // ---------- 3) Mean Time To Recovery ----------
            const mttrCi = computeMttrHours(ciRuns);
            const mttrSec = computeMttrHours(secRuns);

            let mttrCombined = 0;
            if (mttrCi && mttrSec) {
              mttrCombined = (mttrCi + mttrSec) / 2;
            } else if (mttrCi) {
              mttrCombined = mttrCi;
            } else if (mttrSec) {
              mttrCombined = mttrSec;
            }

            core.info(`MTTR (CI workflow) hours: ${mttrCi.toFixed(2)}`);
            core.info(`MTTR (Security workflow) hours: ${mttrSec.toFixed(2)}`);
            core.info(`MTTR (combined) hours: ${mttrCombined.toFixed(2)}`);

            // ---------- Set outputs ----------
            core.setOutput('deployment_frequency', deploymentCount.toString());
            core.setOutput('lead_time_hours_avg', leadTimeAvg.toFixed(2));
            core.setOutput('lead_time_hours_median', leadTimeMedian.toFixed(2));
            core.setOutput('change_failure_rate', changeFailureRate.toFixed(4)); // 0-1
            core.setOutput('mttr_hours', mttrCombined.toFixed(2));

      - name: Print metrics summary
        run: |
          echo "DORA metrics for last $WINDOW_DAYS days (branch: $MAIN_BRANCH)"
          echo "Deployment Frequency (PR merges): ${{ steps.dora.outputs.deployment_frequency }}"
          echo "Lead Time for Changes (avg hours): ${{ steps.dora.outputs.lead_time_hours_avg }}"
          echo "Lead Time for Changes (median hours): ${{ steps.dora.outputs.lead_time_hours_median }}"
          echo "Change Failure Rate: ${{ steps.dora.outputs.change_failure_rate }} (0-1 scale)"
          echo "Mean Time To Recovery (hours): ${{ steps.dora.outputs.mttr_hours }}"
